# Virtual pulldown initialization

```{r}
#| message: false
# Libraries needed
library(igraph)
library(msigdbr)
library(fgsea)
library(ggraph)
```

### Data from inWeb exercise (PPi database from, to, inWeb_cs)

```{r}
load(file='/home/projects/22140/exercise4.Rdata')

```

### If we interested in using STRING PPi data-base (It is about 10-100 GB when compressed)

### Seeds / significant genes of interest

Valid seed inputs are human gene symbols

### Assuming the seeds contain only ensemble ID use this to convert to gene symbols

```{r}
#join deseq and isoform p-values
load(file = "/home/projects/exam_2025_22140_22150/group_2/data/joined_p_values.Rdata")

library(biomaRt)

ensembl <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")


ensembl_list <- seed_proteins

#list create a matrix matching "ensembl_gene_id" to "hgnc_symbol"
mapping <- getBM(
  attributes = c("ensembl_gene_id", "hgnc_symbol"),
  filters = "ensembl_gene_id",
  values = ensembl_list,
  mart = ensembl
)

gene_symbols <- mapping$hgnc_symbol

gene_symbols

```

## Sorting InWeb based on confidence score

```{r}
#Change confidence score. Exercise used >= 0.2. Lower value gives more hit, but more noise.

confidence_score <- 0.2

Sorted_inWeb <- inWeb[inWeb$inweb_cs >= confidence_score, ]

g <- graph_from_data_frame(Sorted_inWeb, directed=FALSE)

length(g)
```

## List of neighboors =\> sub_group

Extract sub-graph (aka virtual pulldown).

```{r}

#List of neighboors
ego_list <- ego(graph = g,order = 1, nodes = V(g)[name %in% gene_symbols], mode = "all")

#List -> Vertex
ego_vertex <- unique(unlist(lapply(ego_list,as_ids)))

#Creates a sub graph based on g using neighbooring nodes 
sub_group <- induced_subgraph(graph = g, vids = V(g)[name %in% ego_vertex])
```

## Filter the virtual pulldown

```{r}
filter_virtual_pulldown <- function(subGraph, parentGraph, cutoff) {
  # Ensure both graphs have vertex 'name' attributes for node matching
  if (is.null(V(subGraph)$name) || is.null(V(parentGraph)$name))
    stop("Both graphs must have vertex 'name' attributes.")
  
  
  mode <- "all"
  # Consider all edge directions when calculating degree
  
  vn <- V(subGraph)$name
  # Extract vertex names from the subgraph
  
  deg_full     <- degree(parentGraph, v = vn, mode = mode)
  deg_internal <- degree(subGraph,            mode = mode)
  # Compute degrees in the parent graph and subgraph
  
  res <- data.frame(
    node          = vn,
    deg_internal  = deg_internal,
    deg_full      = deg_full,
    frac_internal = ifelse(deg_full > 0, deg_internal / deg_full, NA_real_),
    stringsAsFactors = FALSE
  )
  # Create a summary table with internal and full degrees, and their ratio
  
  #nodes_to_keep <- res$node[!is.na(res$frac_internal) & res$frac_internal >= cutoff]    => Original code
  
  nodes_to_keep <- res$node[!is.na(res$frac_internal) & res$frac_internal >= cutoff]
  
  # Select nodes where the fraction of internal connections meets or exceeds the cutoff
  
  filteredSubGraph <- induced_subgraph(subGraph, vids = V(subGraph)[name %in% nodes_to_keep])
  # Generate a new subgraph containing only the selected nodes
  
  V(filteredSubGraph)$frac_internal <- res$frac_internal[match(V(filteredSubGraph)$name, res$node)]
  # Annotate the filtered subgraph with the internal fraction values
  
  filteredSubGraph
}

```

### Visualizing networks

-   As you **raise the cutoff**, the network becomes:

    -   **Smaller**: fewer edges and possibly fewer nodes.

    -   **More focused**: interactions are more likely to be biologically or functionally meaningful.

    -   **Less noisy**: spurious or low-confidence connections are removed.

```{r}
#frac_internal >= cutoff in the virtual pulldown

#change of cutoff values
cuts <- 0.2

filtered <- filter_virtual_pulldown(sub_group, g, cutoff = cuts)
#Stores the subgraph from the function to the global memory

is_seed <- V(filtered)$name %in% gene_symbols

V(filtered)$node_type <- ifelse(is_seed, "seed", "neighbor")

ggraph(filtered, layout = 'fr') + 
  geom_edge_link(width = 0.2, alpha = 0.3) + 
  geom_node_point(aes(color = node_type)) +
  theme_void()

```

```{r}
ggraph(filtered, layout = 'kk') + 
  geom_edge_link(width = 0.2, alpha = 0.3) + 
  geom_node_point(aes(color = node_type)) +
  theme_void()
```

```{r}
ggraph(filtered, layout = 'stress') + 
  geom_edge_link(width = 0.2, alpha = 0.3) + 
  geom_node_point(aes(color = node_type)) +
  theme_void()
```

```{r}
 data.frame(nodedegree = degree(filtered),
            seed = V(filtered)$node_type) |> 
  ggplot(aes(x = nodedegree,
             color = seed))+
   geom_density()
```

```{r}
data.frame(nodebetweeness = betweenness(filtered),
            seed = V(filtered)$node_type) |> 
  ggplot(aes(x = nodebetweeness,
             color = seed))+
   geom_density()+
  ylim(0,5*10^-3)+
  xlim(0,1500)


```

```{r}
big_between <- betweenness(g)

library(tidyverse)
seed_bc1 <- big_between |> 
  as.data.frame() |> 
  rownames_to_column() |> 
  filter(rowname %in% gene_symbols) |> 
  filter(big_between > 1) |> 
  pull(rowname)
  

length(gene_symbols)

V(g)$name %in% gene_symbols
```

```{r}

#List of neighboors
ego_list <- ego(graph = g,order = 1, nodes = V(g)[name %in% seed_bc1], mode = "all")

#List -> Vertex
ego_vertex <- unique(unlist(lapply(ego_list,as_ids)))

#Creates a sub graph based on g using neighbooring nodes 
sub_group <- induced_subgraph(graph = g, vids = V(g)[name %in% ego_vertex])
#frac_internal >= cutoff in the virtual pulldown

#change of cutoff values
cuts <- 0.2



filtered_bc1 <- filter_virtual_pulldown(sub_group, g, cutoff = cuts)
#Stores the subgraph from the function to the global memory

is_seed <- V(filtered_bc1)$name %in% seed_bc1

V(filtered_bc1)$node_type <- ifelse(is_seed, "seed", "neighbor")


ggraph(filtered_bc1, layout = 'fr') + 
  geom_edge_link(width = 0.2, alpha = 0.3) + 
  geom_node_point(aes(color = node_type)) +
  theme_void()

```

```{r}
cl <- cluster_louvain(filtered_bc1, weights = NULL, resolution = 0.5)

V(filtered_bc1)$louvain <- factor(membership(cl))
ggraph(filtered_bc1, layout = "fr") +
  geom_edge_link(alpha = 0.2) +
  geom_node_point(aes(color = louvain, shape = node_type))
```

```{r}
cluster_ids <- c(1,2)
nodes_to_keep <- which(V(filtered_bc1)$louvain %in% cluster_ids)
subg <- induced_subgraph(filtered_bc1, vids = nodes_to_keep)
ggraph(subg, layout = "fr") +
  geom_edge_link(alpha = 0.2) +
  geom_node_point(aes(color = louvain, shape = node_type))

```

```{r}
cluster_ids <- c(9,12)
nodes_to_keep <- which(!(V(filtered_bc1)$louvain %in% cluster_ids))
subg <- induced_subgraph(filtered_bc1, vids = nodes_to_keep)
ggraph(subg, layout = "fr") +
  geom_edge_link(alpha = 0.2) +
  geom_node_point(aes(color = louvain, shape = node_type))
```

```{r}

#detect edges and nodes going between clusters
filtered_bc1

edge_comms <- apply(ends(g, E(g)), 1, function(x) {
  V(g)$community[x[1]] != V(g)$community[x[2]]
})

# Color edges
E(g)$color <- ifelse(edge_comms, "red", "grey80")
E(g)$width <- ifelse(edge_comms, 3, 1)
```

```{r}
ggraph(filtered_bc1, layout = 'stress') + 
  geom_edge_link(width = 0.2, alpha = 0.3) + 
  geom_node_point(aes(color = node_type), size = 0.2) +
  theme_void()
```

```{r}



seed_bc20 <- big_between |> 
  as.data.frame() |> 
  rownames_to_column() |> 
  filter(rowname %in% gene_symbols) |> 
  filter(big_between > 20) |> 
  pull(rowname)

  
#List of neighboors
ego_list <- ego(graph = g,order = 1, nodes = V(g)[name %in% seed_bc20], mode = "all")

#List -> Vertex
ego_vertex <- unique(unlist(lapply(ego_list,as_ids)))

#Creates a sub graph based on g using neighbooring nodes 
sub_group <- induced_subgraph(graph = g, vids = V(g)[name %in% ego_vertex])
#frac_internal >= cutoff in the virtual pulldown

#change of cutoff values
cuts <- 0.2



filtered_bc20 <- filter_virtual_pulldown(sub_group, g, cutoff = cuts)
#Stores the subgraph from the function to the global memory

is_seed <- V(filtered_bc20)$name %in% seed_bc1

V(filtered_bc20)$node_type <- ifelse(is_seed, "seed", "neighbor")


ggraph(filtered_bc20, layout = 'fr') + 
  geom_edge_link(width = 0.2, alpha = 0.3) + 
  geom_node_point(aes(color = node_type)) +
  theme_void()
```

### Functional classification (Cluster_louvain)

```{r}
#Exercise used resolution of 0.4, but a lower value concentrate the nodes to fewer clusters.

cl <- cluster_louvain(graph = filtered, weights = NULL, resolution = 0.4)

V(filtered)$cluster <- factor(membership(cl))

ggraph(filtered,layout='fr') + 
  geom_edge_link(width = 0.2) + 
  geom_node_point(aes(color = cluster)) +
  theme_void()


```

```{r}
n_clusters <- sort(table(V(filtered)$cluster), decreasing = TRUE)
n_clusters
```

This is the end of virtual pulldown. Now comes some analysis of the virtual pull down such as determining biological function of clusters and determining the most central gene.

## Biological function of clusters

1\) genes \<- target \<- genes in cluster

2\) universe \<- filtered

3\) pathways \<- comes from msigdbr (used in W3) which is used to extract data.

```{r}
  BP_df <- msigdbr(species = "human", category = "C5", subcategory = "BP")
  
  BP_list <- split(x = BP_df$gene_symbol, f = BP_df$gs_name)
  
  background <- V(filtered)$name


```

## Gene-set overrepressentation analysis using fora()

```{r}
cluster_count <- length(unique(V(filtered)$cluster))

cluster_count

Top10_biological_function <- function(cluster_number) {
  
  # Extract genes in this cluster
  target <- V(filtered)$name[V(filtered)$cluster == cluster_number]
  
  # Run enrichment
  BP_gsea <- fora(pathways = BP_list, genes = target, universe = background)
  
  # Sort and take top 10
  BP_gsea <- BP_gsea[order(BP_gsea$padj, BP_gsea$pval), ]
  
  head(BP_gsea, 10)
}


```

```{r}
Top10_biological_function(1) #cluster number 1 
```

**Most central gene in each of the clusters**

```{r}

Most_central_gene_in_cluster <- function(cluster_number) {
  
  # Extract subgraph for the given cluster
  g_largest <- induced_subgraph(filtered, vids = V(filtered)[cluster == cluster_number])
  
  # Compute betweenness centrality
  bw <- betweenness(g_largest, directed = FALSE, normalized = TRUE)
  
  # Find the maximum betweenness
  bw_max <- max(bw, na.rm = TRUE)
  
  # Identify the gene(s) with max betweenness
  top_gene <- V(g_largest)$name[bw == bw_max]
  
  return(top_gene)
}

# Example usage
Most_central_gene_in_cluster(4)

```
