# Virtual pulldown

```{r}

# Libraries needed
library(igraph)
library(msigdbr)
library(fgsea)
library(ggraph)
```

### Data from inWeb exercise (PPi database from, to, inWeb_cs)

```{r}
load(file='/home/projects/22140/exercise4.Rdata')

```

### If we interested in using STRING PPi data-base (It is about 10-100 GB when compressed)

### Seeds / significant genes of interest

Valid seed inputs are human gene symbols

```{r}
#EXAMPLE
seeds <- c("ALDH1A2", "BMP2", "CXADR", "GATA4", "HAS2", "NF1", "NKX2-5", "PITX2", "PKD2", "RXRA") 
```

### Assuming the seeds contain only ensemble ID use this to convert to gene symbols

```{r}

library(biomaRt)

ensembl <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")

ensembl_list <- c("ENSG00000125538", "ENSG00000125845", "ENSG00000139618")  # example

#list create a matrix matching "ensembl_gene_id" to "hgnc_symbol"
mapping <- getBM(
  attributes = c("ensembl_gene_id", "hgnc_symbol"),
  filters = "ensembl_gene_id",
  values = ensembl_list,
  mart = ensembl
)

gene_symbols <- mapping$hgnc_symbol

gene_symbols

```

```{r}
#Change confidence score. Exercise used >= 0.2. Lower value gives more hit, but more noise.

confidence_score <- 0.2

Sorted_inWeb <- inWeb[inWeb$inweb_cs >= confidence_score, ]

g <- graph_from_data_frame(Sorted_inWeb, directed=FALSE)

length(g)
```

## List of neighboors =\> sub_group

Extract sub-graph (aka virtual pulldown).

```{r}

#List of neighboors
ego_list <- ego(graph = g,order = 1, nodes = V(g)[name %in% seeds], mode = "all")

#List -> Vertex
ego_vertex <- unique(unlist(lapply(ego_list,as_ids)))

#Creates a sub graph based on g using neighbooring nodes 
sub_group <- induced_subgraph(graph = g, vids = V(g)[name %in% ego_vertex])
```

Filter the virtual pulldown

```{r}
filter_virtual_pulldown <- function(subGraph, parentGraph, cutoff) {
  # Ensure both graphs have vertex 'name' attributes for node matching
  if (is.null(V(subGraph)$name) || is.null(V(parentGraph)$name))
    stop("Both graphs must have vertex 'name' attributes.")
  
  
  mode <- "all"
  # Consider all edge directions when calculating degree
  
  vn <- V(subGraph)$name
  # Extract vertex names from the subgraph
  
  deg_full     <- degree(parentGraph, v = vn, mode = mode)
  deg_internal <- degree(subGraph,            mode = mode)
  # Compute degrees in the parent graph and subgraph
  
  res <- data.frame(
    node          = vn,
    deg_internal  = deg_internal,
    deg_full      = deg_full,
    frac_internal = ifelse(deg_full > 0, deg_internal / deg_full, NA_real_),
    stringsAsFactors = FALSE
  )
  # Create a summary table with internal and full degrees, and their ratio
  
  #nodes_to_keep <- res$node[!is.na(res$frac_internal) & res$frac_internal >= cutoff]    => Original code
  
  nodes_to_keep <- res$node[!is.na(res$frac_internal) & res$frac_internal >= cutoff]
  
  # Select nodes where the fraction of internal connections meets or exceeds the cutoff
  
  filteredSubGraph <- induced_subgraph(subGraph, vids = V(subGraph)[name %in% nodes_to_keep])
  # Generate a new subgraph containing only the selected nodes
  
  V(filteredSubGraph)$frac_internal <- res$frac_internal[match(V(filteredSubGraph)$name, res$node)]
  # Annotate the filtered subgraph with the internal fraction values
  
  filteredSubGraph
}

```

-   As you **raise the cutoff**, the network becomes:

    -   **Smaller**: fewer edges and possibly fewer nodes.

    -   **More focused**: interactions are more likely to be biologically or functionally meaningful.

    -   **Less noisy**: spurious or low-confidence connections are removed.

### Visualizing networks

```{r}
#frac_internal >= cutoff in the virtual pulldown

#change of cutoff values
cuts <- 0.5

filtered <- filter_virtual_pulldown(sub_group, g, cutoff = cuts)
#Stores the subgraph from the function to the global memory

is_seed <- V(filtered)$name %in% seeds

V(filtered)$node_type <- ifelse(is_seed, "seed", "neighbor")

ggraph(filtered, layout = 'fr') + 
  geom_edge_link(width = 0.2) + 
  geom_node_point(aes(color = node_type)) +
  theme_void()

```

### Functional classification (Cluster_louvain)

```{r}
#Exercise used resolution of 0.4, but a lower value concentrate the nodes to fewer clusters.

cl <- cluster_louvain(graph = filtered, weights = NULL, resolution = 0.4)

V(filtered)$cluster <- factor(membership(cl))

ggraph(filtered,layout='fr') + 
  geom_edge_link(width = 0.2) + 
  geom_node_point(aes(color = cluster)) +
  theme_void()


```

This is the end of virtual pulldown. Now comes some analysis of the virtual pull down such as determining biological function of clusters and determining the most central gene.

## Biological function of clusters

1\) genes \<- target \<- genes in cluster 4 (and 1+3)

2\) universe \<- filteredsubgraph

3\) pathways \<- comes from msigdbr (used in W3) which is used to extract data.

```{r}
BP_df <- msigdbr(species = "human", category = "C5", subcategory = "BP")
BP_list <- split(x = BP_df$gene_symbol, f = BP_df$gs_name)

background <- V(filteredSubGraph)$name



```

```{r}
cluster_count <- length(unique(V(filtered)$cluster))

Top10_biological_function <- function(number) {
  
  # Select genes in the given cluster
  target <- V(filteredSubGraph)$name[V(filteredSubGraph)$cluster == number]
  
  # Run enrichment
  BP_gsea <- fora(pathways = BP_list, genes = target, universe = background)
  
  # Take top 10 hits sorted by padj then pval
  top10 <- head(BP_gsea[order(BP_gsea$padj, BP_gsea$pval), ], 10)
  
  return(top10)
}



```

```{r}


target <- V(filteredSubGraph)$name[V(filteredSubGraph)$cluster == 4]

BP_gsea <- fora(pathways = BP_list, genes = target, universe = background)

top10_bp <- head(BP_gsea[order(BP_gsea$padj, BP_gsea$pval), ], 10)



#now we change the target so it fits with the other 2 clusters
target2 <- V(filteredSubGraph)$name[V(filteredSubGraph)$cluster == 1]
target3 <- V(filteredSubGraph)$name[V(filteredSubGraph)$cluster == 3]

BP_gsea2 <- fora(pathways = BP_list, genes = target2, universe = background)
BP_gsea3 <- fora(pathways = BP_list, genes = target3, universe = background)

```
