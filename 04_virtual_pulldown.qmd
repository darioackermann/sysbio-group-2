# Virtual pulldown initialization

```{r}

# Libraries needed
library(igraph)
library(msigdbr)
library(fgsea)
library(ggraph)
```

### Data from inWeb exercise (PPi database from, to, inWeb_cs)

```{r}
load(file='/home/projects/22140/exercise4.Rdata')
load(file ="/home/projects/exam_2025_22140_22150/group_2/data/dseq_signif_genes.Rdata")

```

### If we interested in using STRING PPi data-base (It is about 10-100 GB when compressed)

### Seeds / significant genes of interest

Valid seed inputs are human gene symbols

```{r}
#EXAMPLE USAGE
seeds <- c("ALDH1A2", "BMP2", "CXADR", "GATA4", "HAS2", "NF1", "NKX2-5", "PITX2", "PKD2", "RXRA") 
```

### Assuming the seeds contain only ensemble ID use this to convert to gene symbols

```{r}

library(biomaRt)

ensembl <- useMart("ensembl", dataset = "hsapiens_gene_ensembl")

ensembl_list <- c(deseq_signif_genes)  # EXAMPLE change this 

#list create a matrix matching "ensembl_gene_id" to "hgnc_symbol"
mapping <- getBM(
  attributes = c("ensembl_gene_id", "hgnc_symbol"),
  filters = "ensembl_gene_id",
  values = ensembl_list,
  mart = ensembl
)

gene_symbols <- mapping$hgnc_symbol

seeds <- gene_symbols

length(seeds)
```

## Sorting InWeb based on confidence score

```{r}
#Change confidence score. Exercise used >= 0.2. Lower value gives more hit, but more noise.

confidence_score <- 0.2

Sorted_inWeb <- inWeb[inWeb$inweb_cs >= confidence_score, ]

g <- graph_from_data_frame(Sorted_inWeb, directed=FALSE)

length(g)
```

## List of neighboors =\> sub_group

Extract sub-graph (aka virtual pulldown).

```{r}

#List of neighboors
ego_list <- ego(graph = g,order = 1, nodes = V(g)[name %in% seeds], mode = "all")

#List -> Vertex
ego_vertex <- unique(unlist(lapply(ego_list,as_ids)))

#Creates a sub graph based on g using neighbooring nodes 
sub_group <- induced_subgraph(graph = g, vids = V(g)[name %in% ego_vertex])
```

## Filter the virtual pulldown

```{r}
filter_virtual_pulldown <- function(subGraph, parentGraph, cutoff) {
  # Ensure both graphs have vertex 'name' attributes for node matching
  if (is.null(V(subGraph)$name) || is.null(V(parentGraph)$name))
    stop("Both graphs must have vertex 'name' attributes.")
  
  
  mode <- "all"
  # Consider all edge directions when calculating degree
  
  vn <- V(subGraph)$name
  # Extract vertex names from the subgraph
  
  deg_full     <- degree(parentGraph, v = vn, mode = mode)
  deg_internal <- degree(subGraph,            mode = mode)
  # Compute degrees in the parent graph and subgraph
  
  res <- data.frame(
    node          = vn,
    deg_internal  = deg_internal,
    deg_full      = deg_full,
    frac_internal = ifelse(deg_full > 0, deg_internal / deg_full, NA_real_),
    stringsAsFactors = FALSE
  )
  # Create a summary table with internal and full degrees, and their ratio
  
  #nodes_to_keep <- res$node[!is.na(res$frac_internal) & res$frac_internal >= cutoff]    => Original code
  
  nodes_to_keep <- res$node[!is.na(res$frac_internal) & res$frac_internal >= cutoff]
  
  # Select nodes where the fraction of internal connections meets or exceeds the cutoff
  
  filteredSubGraph <- induced_subgraph(subGraph, vids = V(subGraph)[name %in% nodes_to_keep])
  # Generate a new subgraph containing only the selected nodes
  
  V(filteredSubGraph)$frac_internal <- res$frac_internal[match(V(filteredSubGraph)$name, res$node)]
  # Annotate the filtered subgraph with the internal fraction values
  
  filteredSubGraph
}

```

### Visualizing networks

-   As you **raise the cutoff**, the network becomes:

    -   **Smaller**: fewer edges and possibly fewer nodes.

    -   **More focused**: interactions are more likely to be biologically or functionally meaningful.

    -   **Less noisy**: spurious or low-confidence connections are removed.

```{r}
#frac_internal >= cutoff in the virtual pulldown

#change of cutoff values
cuts <- 0.2

filtered <- filter_virtual_pulldown(sub_group, g, cutoff = cuts)
#Stores the subgraph from the function to the global memory

length(filtered)

is_seed <- V(filtered)$name %in% seeds

V(filtered)$node_type <- ifelse(is_seed, "seed", "neighbor")

p1 <- ggraph(filtered, layout = 'kk') + 
  geom_edge_link(width = 0.2) + 
  geom_node_point(aes(color = node_type)) +
  theme_void()

ggsave("04_node_type_plot_cutoff_02.png", plot = p1, width = 18, height = 14, dpi = 300)

```

### Functional classification (Cluster_louvain)

```{r}
#Exercise used resolution of 0.4, but a lower value concentrate the nodes to fewer clusters.

cl <- cluster_louvain(graph = filtered, weights = NULL, resolution = 0.2)

V(filtered)$cluster <- factor(membership(cl))

p2 <- ggraph(filtered,layout='kk') + 
  geom_edge_link(width = 0.1) + 
  geom_node_point(aes(color = cluster)) +
  theme_void()

ggsave("04_cluster_louvain_plot_resolution_02.png", plot = p2, width = 14, height = 14, dpi = 300)

```

```{r}
n_clusters <- sort(table(V(filtered)$cluster), decreasing = TRUE)
n_clusters
```

This is the end of virtual pulldown. Now comes some analysis of the virtual pull down such as determining biological function of clusters and determining the most central genes of each cluster.

## Biological function of clusters

1\) genes \<- target \<- genes in cluster

2\) universe \<- filtered

3\) pathways \<- comes from msigdbr (used in W3) which is used to extract data.

```{r}
  BP_df <- msigdbr(species = "human", category = "C5", subcategory = "BP")
  
  BP_list <- split(x = BP_df$gene_symbol, f = BP_df$gs_name)
  
  background <- V(filtered)$name


```

## Gene-set overrepressentation analysis using fora()

```{r}
Top10_biological_function <- function(cluster_number) {
  
  # Extract genes in this cluster
  target <- V(filtered)$name[V(filtered)$cluster == cluster_number]
  
  # Run enrichment
  BP_gsea <- fora(pathways = BP_list, genes = target, universe = background)
  
  # Sort and take top 10
  BP_gsea <- BP_gsea[order(BP_gsea$padj, BP_gsea$pval), ]
  
  head(BP_gsea, 10)
}

cluster_count <- length(unique(V(filtered)$cluster))

cluster_count

```

```{r}
Top10_biological_function() #cluster number 
```

**Most central gene in each of the clusters**

```{r}

Most_central_gene_in_cluster <- function(cluster_number) {
  
  # Extract subgraph for the given cluster
  g_largest <- induced_subgraph(filtered, vids = V(filtered)[cluster == cluster_number])
  
  # Compute betweenness centrality
  bw <- betweenness(g_largest, directed = FALSE, normalized = TRUE)
  
  # Find the maximum betweenness
  bw_max <- max(bw, na.rm = TRUE)
  
  # Identify the gene(s) with max betweenness
  top_gene <- V(g_largest)$name[bw == bw_max]
  
  return(top_gene)
}

# Example usage
Most_central_gene_in_cluster(2)

```
